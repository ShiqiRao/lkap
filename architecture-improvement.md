# 架构改进：全局链接引用系统

## 问题分析

用户正确指出了 `parseDocumentLinks` 中的一个重要架构缺陷：

**原始问题**:
```typescript
// 原始实现 (有bug)
static parseDocumentLinks(document: vscode.TextDocument): ParsedLink[] {
  const linkReferences = this.extractLinkReferences(text); // 只从当前文档提取
  const wikiLinks = this.parseWikiLinks(text, document, linkReferences);
  // ...
}
```

这个实现只从当前文档提取链接引用，但实际上Wiki链接可能需要引用其他文档的metadata。例如：

- 文档A包含 `[[interview-questions]]`
- 文档B的metadata中定义了 `[interview-questions]: notes/interview-questions.md`
- 原始实现无法将A中的链接正确解析到B定义的路径

## 解决方案

### 1. 全局链接引用系统

重新设计了架构，将链接引用管理移到 `LinkIndexManager` 中：

```typescript
// LinkIndexManager.ts
private globalLinkReferences: Map<string, LinkReference> = new Map();

// 两阶段索引构建
async buildIndex(): Promise<void> {
  // 第一阶段：从所有文档提取链接引用
  await this.buildGlobalLinkReferences();

  // 第二阶段：使用全局引用解析所有链接
  const allLinks = await LinkParser.findAllLinksWithReferences(this.globalLinkReferences);
}
```

### 2. 新的解析流程

```typescript
// LinkParser.ts
static parseDocumentLinksWithReferences(
  document: vscode.TextDocument,
  globalReferences: Map<string, LinkReference>
): ParsedLink[] {
  // 使用全局引用而不是仅本地引用
  const wikiLinks = this.parseWikiLinks(text, document, globalReferences);
  // ...
}
```

### 3. 实时更新机制

当单个文档更新时：

```typescript
async updateLinksForFile(filePath: string, document?: vscode.TextDocument): Promise<void> {
  // 1. 更新该文档的链接引用到全局索引
  const fileReferences = LinkParser.extractLinkReferencesFromDocument(document);
  for (const [name, reference] of fileReferences) {
    this.globalLinkReferences.set(name, reference);
  }

  // 2. 使用更新后的全局引用重新解析链接
  const links = LinkParser.parseDocumentLinksWithReferences(document, this.globalLinkReferences);
}
```

## 架构改进

### 新增组件

1. **全局引用管理器**:
   - `buildGlobalLinkReferences()`: 从所有文档构建全局引用
   - `getGlobalLinkReferences()`: 获取当前全局引用
   - `globalLinkReferences`: 全局引用存储

2. **新的解析方法**:
   - `parseDocumentLinksWithReferences()`: 使用全局引用解析文档
   - `findAllLinksWithReferences()`: 使用全局引用查找所有链接
   - `extractLinkReferencesFromDocument()`: 公开方法提取文档引用

3. **兼容性支持**:
   - 保留原有 `parseDocumentLinks()` 方法向后兼容
   - 渐进式升级，不破坏现有功能

### 性能优化

1. **缓存机制**:
   - 全局引用存储在内存中，避免重复解析
   - 只在文档更新时增量更新引用

2. **两阶段构建**:
   - 第一阶段快速扫描所有metadata
   - 第二阶段使用完整引用进行精确解析

3. **智能更新**:
   - 文件监视器只更新变化文档的引用
   - 避免全量重建索引

## 使用场景验证

### 场景1: 跨文档引用
```markdown
// 文档A.md
[[interview-questions]]  // 没有本地metadata

// 文档B.md
[//begin]: # "Autogenerated link references"
[interview-questions]: notes/interview-questions.md "interview-questions"
[//end]: # "Autogenerated link references"
```

**结果**: 文档A中的链接正确解析到 `notes/interview-questions.md`

### 场景2: 工作区级别链接
```markdown
// docs/development.md
[[音乐制作]]  // 链接到notes目录

// notes/some-file.md
[音乐制作]: 音乐制作.md "音乐制作"
```

**结果**: 跨目录链接正确解析

## 技术改进

1. ✅ **正确性**: 解决了链接解析的准确性问题
2. ✅ **性能**: 全局缓存避免重复解析
3. ✅ **扩展性**: 支持工作区级别的复杂链接关系
4. ✅ **兼容性**: 保持向后兼容
5. ✅ **维护性**: 清晰的职责分离

这个改进解决了原始架构的根本问题，使LKAP能够正确处理复杂的工作区链接场景。
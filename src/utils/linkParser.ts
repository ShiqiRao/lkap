import * as vscode from 'vscode';
import * as path from 'path';
import { ParsedLink, LinkReference } from '../types';
import { FileUtils } from './fileUtils';

/**
 * Link parser utility class
 * Parses both wiki-style links [[note-name]] and standard markdown links [text](path)
 */
export class LinkParser {
  // Wiki-style links pattern: [[link-text]] or [[link-text|display-text]]
  private static readonly WIKI_LINK_PATTERN = /\[\[(.*?)(?:\|(.*?))?\]\]/g;

  // Markdown links pattern: [text](path)
  private static readonly MD_LINK_PATTERN = /\[(.*?)\]\((.*?)\)/g;

  // Autogenerated link references pattern: [reference]: path "title"
  private static readonly LINK_REF_PATTERN = /^\[(.*?)\]:\s*([^\s]+)(?:\s+"([^"]*)")?/gm;

  /**
   * Parse all links from a document
   * @param document The document to parse
   * @returns Array of parsed links
   */
  static parseDocumentLinks(document: vscode.TextDocument): ParsedLink[] {
    const text = document.getText();
    const links: ParsedLink[] = [];

    // Extract link references first (metadata)
    const linkReferences = this.extractLinkReferences(text);

    // Parse wiki-style links (using link references for resolution)
    const wikiLinks = this.parseWikiLinks(text, document, linkReferences);
    links.push(...wikiLinks);

    // Parse markdown-style links (only include .md links to avoid external URLs)
    const mdLinks = this.parseMarkdownLinks(text, document);
    links.push(...mdLinks);

    // Parse autogenerated link references
    const linkRefs = this.parseLinkReferences(text, document);
    links.push(...linkRefs);

    return links;
  }

  /**
   * Extract link references from document text
   * @param text The document text
   * @returns Map of reference names to link references
   */
  private static extractLinkReferences(text: string): Map<string, LinkReference> {
    const references = new Map<string, LinkReference>();
    let match: RegExpExecArray | null;

    // Reset regex lastIndex to ensure we start from the beginning
    this.LINK_REF_PATTERN.lastIndex = 0;

    while ((match = this.LINK_REF_PATTERN.exec(text)) !== null) {
      const refName = match[1];
      const linkPath = match[2];
      const linkTitle = match[3];

      // Skip comment markers and other non-link references
      if (refName.startsWith('//') || linkPath === '#') {
        continue;
      }

      references.set(refName, {
        name: refName,
        path: linkPath,
        title: linkTitle
      });
    }

    return references;
  }

  /**
   * Parse wiki-style links from text
   * @param text The text to parse
   * @param document The source document
   * @param linkReferences Map of link references from metadata
   * @returns Array of parsed wiki links
   */
  private static parseWikiLinks(text: string, document: vscode.TextDocument, linkReferences: Map<string, LinkReference>): ParsedLink[] {
    const links: ParsedLink[] = [];
    let match: RegExpExecArray | null;

    while ((match = this.WIKI_LINK_PATTERN.exec(text)) !== null) {
      const fullMatch = match[0]; // The entire [[link]] match
      const linkText = match[1]; // The text inside the brackets
      const displayText = match[2] || linkText; // Display text if provided, otherwise use link text

      // Get the position of the link in the document
      const startPos = document.positionAt(match.index);
      const endPos = document.positionAt(match.index + fullMatch.length);
      const range = new vscode.Range(startPos, endPos);

      // Determine the target file using link references if available
      const targetFile = this.resolveWikiLinkTarget(linkText, document.uri.fsPath, linkReferences);

      links.push({
        title: displayText,
        range: range,
        targetFile: targetFile,
        sourceFile: document.uri.fsPath
      });
    }

    return links;
  }

  /**
   * Parse markdown-style links from text
   * @param text The text to parse
   * @param document The source document
   * @returns Array of parsed markdown links
   */
  private static parseMarkdownLinks(text: string, document: vscode.TextDocument): ParsedLink[] {
    const links: ParsedLink[] = [];
    let match: RegExpExecArray | null;

    while ((match = this.MD_LINK_PATTERN.exec(text)) !== null) {
      const fullMatch = match[0]; // The entire [text](path) match
      const linkText = match[1]; // The text part
      const linkPath = match[2]; // The path part

      // Only include markdown links that point to .md files
      // Skip external URLs and other resources
      if (!linkPath.endsWith('.md') || linkPath.startsWith('http')) {
        continue;
      }

      // Get the position of the link in the document
      const startPos = document.positionAt(match.index);
      const endPos = document.positionAt(match.index + fullMatch.length);
      const range = new vscode.Range(startPos, endPos);

      // Resolve the target file path
      const targetFile = this.resolveMarkdownLinkTarget(linkPath, document.uri.fsPath);

      links.push({
        title: linkText,
        range: range,
        targetFile: targetFile,
        sourceFile: document.uri.fsPath
      });
    }

    return links;
  }

  /**
   * Parse autogenerated link references from text
   * @param text The text to parse
   * @param document The source document
   * @returns Array of parsed link references
   */
  private static parseLinkReferences(text: string, document: vscode.TextDocument): ParsedLink[] {
    const links: ParsedLink[] = [];
    let match: RegExpExecArray | null;

    // Reset regex lastIndex to ensure we start from the beginning
    this.LINK_REF_PATTERN.lastIndex = 0;

    while ((match = this.LINK_REF_PATTERN.exec(text)) !== null) {
      const fullMatch = match[0]; // The entire [reference]: path "title" match
      const refName = match[1];    // The reference name
      const linkPath = match[2];   // The path part
      const linkTitle = match[3] || refName; // The title if provided, otherwise use ref name

      // Only include markdown links that point to .md files
      // Skip external URLs and other resources
      if (!linkPath.endsWith('.md') || linkPath.startsWith('http')) {
        continue;
      }

      // Get the position of the link in the document
      const startPos = document.positionAt(match.index);
      const endPos = document.positionAt(match.index + fullMatch.length);
      const range = new vscode.Range(startPos, endPos);

      // Resolve the target file path
      const targetFile = this.resolveMarkdownLinkTarget(linkPath, document.uri.fsPath);

      links.push({
        title: linkTitle,
        range: range,
        targetFile: targetFile,
        sourceFile: document.uri.fsPath
      });
    }

    return links;
  }

  /**
   * Resolve a wiki link to a target file path
   * @param linkText The text of the wiki link
   * @param sourcePath The path of the source file
   * @param linkReferences Map of link references from metadata
   * @returns The absolute path to the target file
   */
  private static resolveWikiLinkTarget(linkText: string, sourcePath: string, linkReferences: Map<string, LinkReference>): string {
    try {
      // First, check if there's a link reference for this wiki link
      const linkRef = linkReferences.get(linkText);
      if (linkRef) {
        // Use the path from the link reference, relative to the source file
        const decodedPath = decodeURIComponent(linkRef.path);

        if (path.isAbsolute(decodedPath)) {
          return decodedPath;
        }

        // Relative to the source file directory
        const sourceDir = path.dirname(sourcePath);
        return path.resolve(sourceDir, decodedPath);
      }

      // Fallback to the original logic if no link reference is found
      const config = vscode.workspace.getConfiguration('lkap');
      const notesPath = config.get<string>('notesPath', './notes');
      const absNotesPath = FileUtils.resolveWorkspacePath(notesPath);

      // Preserve the original link text as much as possible for filename
      // Only replace characters that are truly invalid for filenames
      const sanitizedName = linkText
        .trim()
        // Replace characters that are invalid in filenames on Windows/Mac/Linux
        .replace(/[<>:"/\\|?*]/g, '')
        // Optionally replace multiple consecutive spaces with single spaces
        .replace(/\s+/g, ' ');

      // Combine with notes path to get the target file
      return path.join(absNotesPath, `${sanitizedName}.md`);
    } catch (error) {
      console.error('Error resolving wiki link target:', error);
      return '';
    }
  }

  /**
   * Resolve a markdown link to a target file path
   * @param linkPath The path in the markdown link
   * @param sourcePath The path of the source file
   * @returns The absolute path to the target file
   */
  private static resolveMarkdownLinkTarget(linkPath: string, sourcePath: string): string {
    try {
      // Decode URL-encoded characters (e.g., %20 for spaces)
      const decodedPath = decodeURIComponent(linkPath);

      // If it's already absolute, return as is
      if (path.isAbsolute(decodedPath)) {
        return decodedPath;
      }

      // Relative to the source file
      const sourceDir = path.dirname(sourcePath);
      return path.resolve(sourceDir, decodedPath);
    } catch (error) {
      console.error('Error resolving markdown link target:', error);
      return '';
    }
  }

  /**
   * Find all wiki links in a workspace
   * @returns Promise resolving to an array of parsed links
   */
  static async findAllLinks(): Promise<ParsedLink[]> {
    const allLinks: ParsedLink[] = [];

    // Get all markdown files
    const mdFiles = await FileUtils.getMarkdownFiles();

    for (const fileUri of mdFiles) {
      try {
        const document = await vscode.workspace.openTextDocument(fileUri);
        const documentLinks = this.parseDocumentLinks(document);
        allLinks.push(...documentLinks);
      } catch (error) {
        console.error(`Error parsing links from ${fileUri.fsPath}:`, error);
      }
    }

    return allLinks;
  }
}